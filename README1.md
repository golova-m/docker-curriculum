<img src="https://raw.githubusercontent.com/protsenkovi/docker-curriculum/master/images/logo.png" alt="docker logo">

<a id="table-of-contents"></a>
## Оглавление

-	[Предисловие](#preface)
    -	[Предварительные требования](#prerequisites)
    -   [Настройка компьютера](#setup)
-   [1 Играем с Busybox](#busybox)
    -	[1.1 Docker Run](#dockerrun)
    -	[1.2 Терминология](#terminology)
-   [2 Веб-приложения с Docker](#webapps)
    -	[2.1 Статические сайты](#static-site)
    -	[2.2 Docker образы (image)](#docker-images)
    -	[2.3 Наш первый образ](#our-image)
    -	[2.4 Dockerfile](#dockerfiles)
    -	[2.5 Docker на AWS](#docker-aws)


------------------------------

## Предисловие

> Внимание: Данная лабораторная предполагает использование Docker версии  **1.12.0-rc2**. Если какая-либо часть будет несовместима с более новыми версиями, откройте [issue](https://github.com/prakhar1989/docker-curriculum/issues). Спасибо!

<a id="prerequisites"></a>
### Предварительные требования

Для прохождения данной лабораторной не потребуется специальной подготовки, кроме уверенного использования командной строки и текстового редактора. Прошлый опыт разработки веб-приложений не требуется, но будет полезен. По мере прохождения обучения мы будем использовать облачные сервисы. Вам понадобится создать аккаунт на следующих сайтах:

- [Amazon Web Services](http://aws.amazon.com/),
- [Docker Hub](https://hub.docker.com/).

<a id="setup"></a>
### Настраиваем компьютер

Установка и настройка всех необходимых инструментов может быть утомительной задачей, но, к счастью, Docker стал довольно стабильным, и установка и запуск его на любой ОС стала простым. Итак, установим Docker.

Ещё несколько релизов назад запуск Докера на OS X и Windows был проблемным, но команда разработчиков проделала огромную работу. Сегодня весь процесс и ежу понятен. На официальном сайте вы можете найти подробные инструкции по установке на [Mac](https://www.docker.com/products/docker#/mac), [Linux](https://www.docker.com/products/docker#/linux) and [Windows](https://www.docker.com/products/docker#/windows).

Вы можете также создать виртуальную машину VMWare или VirtualBox на основе образа [`boot2docker.iso`](https://github.com/boot2docker/boot2docker/releases). Для подключения к виртуальной машине по ssh узнайте ip машины командой `ip addr` и залогиньтесь в неё под именем `docker` c паролем `tcuser`.

Проверим, всё ли установлено корректно:

```
$ docker run hello-world

Hello from Docker.
This message shows that your installation appears to be working correctly.
...
```
___________

<a href="#table-of-contents" class="Top">К оглавлению</a>
<a id="busybox"></a>
## 1 Играем с BusyBox

Теперь, когда всё подготовлено, пора приняться за дело. В этом разделе нашей целью будет запуск контейнера [Busybox](https://en.wikipedia.org/wiki/BusyBox) и освоение команды `docker run`.

Для начала, запустите следующую команду:
```
$ docker pull busybox
```

> Внимание: В зависимости от того, как вы установили Docker, вы можете увидеть сообщение `permission denied` (доступ запрещён) в ответ на вызов выше приведённой команды. Если вы на Mac, убедитесь, что Docker движок запущен. Если на Линукс, вам может потребоваться повысить права доступа с помощью команды `sudo`. В качестве альтернативного варианта вы можете создать [Docker группу](https://docs.docker.com/engine/installation/linux/linux-postinstall/) для решения этой проблемы.

Команда `pull` скачивает [образ busybox](https://hub.docker.com/_/busybox/) из [**Docker registry**](https://hub.docker.com/explore/) и сохраняет его в систему. Вы можете использовать команду `docker images` для вывода в консоль списка образов находящихся в вашей системе.

```
root@boot2docker:/home/docker# docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
busybox             latest              00f017a8c2a6        2 weeks ago         1.11 MB
hello-world         latest              48b5124b2768        2 months ago        1.84 kB
```

<a id="dockerrun"></a>
### 1.1 Запуск Docker

Великолепно! Теперь перейдём к запуску **контейнера** на основе этого образа. Для этого мы воспользуемся всемогущей командой `docker run`.

```
$ docker run busybox
$
```

Постойте, но ничего не произошло! Это баг? Ну, нет. Под капотом произошло много всего. Когда вы запустили команду `run`, клиент Docker нашёл образ (в нашем случае, busybox), загрузил контейнер и запустил команду внутри этого контейнера. Мы выполнили `docker run busybox`, но не указали никаких аргументов, так что контейнер загрузился, выполнил команду `sh` и процесс контейнер завершился. Ну, да, как-то обидно. Попробуем сделать что-нибудь поинтереснее.

```
$ docker run busybox echo "hello from busybox"
hello from busybox
```

Ура, наконец-то что-то вывелось. В данном случае Docker клиент добросовестно запустил команду `echo` внутри контейнера, а затем вышел из него. Вы, наверное, заметили, что всё произошло очень быстро. А теперь представьте себе процесс загрузки виртуальной машины, выполнения в ней команды и её выключения. Теперь ясно, почему говорят, что контейнеры быстрые! Чтобы узнать время выполнения попробуйте запустить последнюю команду со словом `time` в начале.

Теперь давайте взглянем на команду `docker ps`. Она выводит на экран список всех запущенных контейнеров.

```
docker@boot2docker:~$ docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
```

В силу того, что ни один контейнер не запушен, выводится пустая строка. Попробуем более информативный вариант `docker ps -a`:

```
docker@boot2docker:~$ docker ps -a
CONTAINER ID        IMAGE               COMMAND             CREATED              STATUS                          PORTS               NAMES
56fdebcf3df0        busybox             "echo hi"           About a minute ago   Exited (0) About a minute ago                       jovial_wozniak
5f585bdd9545        busybox             "echo hi"           About a minute ago   Exited (0) About a minute ago                       focused_golick
ad64717b0d60        busybox             "sh"                8 minutes ago        Exited (0) 8 minutes ago                            determined_hugle
c73ceb428f23        hello-world         "/hello"            25 minutes ago       Exited (0) 25 minutes ago                           sad_mestorf
```

То, что мы видим в выдаче — список всех контейнеров, которые были запущены ранее. Обратите внимание, что колонка `STATUS` показывает, что эти контейнеры остановились несколько минут назад. 

Наверное вы удивляетесь, существует ли способ запустить более одной команды в контейнере. Давайте попробуем:

```
$ docker run -it busybox sh
/ # ls
bin   dev   etc   home  proc  root  sys   tmp   usr   var
/ # uptime
 05:45:21 up  5:58,  0 users,  load average: 0.00, 0.01, 0.04
```

Выполнение команды `run` с флагами `-it` подключает нас к интерактивному терминалу tty в контейнере. Теперь мы можем запустить столько команд, сколько захотим. Уделите немного времени запуску ваших любимых команд в этой консоли.

> **Опасная зона**: Если вы любите рисковать, вы можете попробовать выполнить команду `rm -rf bin`. Убедитесь, что выполняете команду в контейнере, а **не** в основной операционной системе. Удалив данной командой папку bin не даст возможности запускать команды как `ls`, `echo`. После того, как всё перестанет работать, вы можете выйти из контейнера (выполним команду `exit`), а затем запустить контейнер заново `docker run -it busybox sh`. Так как Docker каждый раз создаёт новый контейнер, папка bin и команды должны быть опять доступны.

> В Docker 1.3 запуск контейнера и создание слоя файловой системы может быть разделён. Проделайте аналогичный выше пример, но с командами `create`, `start`. Запуск команды `docker create -it busybox sh` создаст слой файловой системы контейнера. Затем командой `docker start -ia <id_контейнера>` вы можете запустить выполнение контейнера в интерактивном режиме. Проанализируйте, что произошло при повторном запуске. 

На этом захватывающий тур по возможностям команды docker run закончен. Скорее всего, вы будете использовать эту команду довольно часто. Так что важно, чтобы мы поняли как с ней обращаться. Чтобы узнать больше о run, используйте `docker run --help`, и увидите полный список поддерживаемых флагов. Скоро мы увидим еще несколько способов использования `docker run`.

Перед тем, как продолжать, давайте вкратце рассмотрим удаление контейнеров. Мы видели выше, что с помощью команды `docker ps -a` всё ещё можно увидеть остатки завершённых контейнеров. На протяжении этого пособия, вы будете запускать `docker run` несколько раз, и оставшиеся, покинутые контейнеры будут съедать дисковое пространство. Так что если они больше вам не понадобятся, вы можете взять за правило удалять контейнеры после завершения работы с ними. Для этого используется команда `docker rm`. Просто скопируйте ID (можно несколько) из вывода выше и передайте параметрами в команду.
```
$ docker rm 305297d7a235 ff0a5c3750b9
305297d7a235
ff0a5c3750b9
```

При удалении идентификаторы будут снова выведены на экран. Если нужно удалить много контейнеров, то вместо ручного копирования и вставки можно сделать так:

```
$ docker rm $(docker ps -a -q -f status=exited)
```

Эта команда удаляет все контейнеры, у которых статус `exited`. Флаг `-q` возвращает только численные ID, а флаг `-f` фильтрует вывод на основе предоставленных условий. Последняя полезная деталь — команде `docker run` можно передать флаг `--rm`, тогда контейнер будет автоматически удаляться при завершении. Это очень удобно для разовых запусков и экспериментов с Docker.

По образу и подобию можно удалять ненужные образы командой `docker rmi`.

<a id="terminology"></a>

### 1.2 Терминология

В предыдущем разделе мы использовали много специфичного для Docker жаргона, и многих это может запутать. Перед тем, как продолжать, давайте разберем некоторые термины, которые часто используются в экосистеме Docker.

- *Image* (образ) - файловая система и параметры, с которыми будет произведён запуск. Образ не содержит изменяемого состояния и никогда не изменяется. В примере выше мы использовали команду `docker pull` чтобы скачать образ **busybox**.
- *Container* (контейнер) - Создаётся на основе образа и запускает само приложение. Мы создали контейнер командой `docker run`, и использовали образ **busybox**, скачанный ранее. Список запущенных контейнеров можно увидеть с помощью команды `docker ps`.
- *Docker Daemon* (Docker демон) - Фоновый сервис, запущенный в хост операционной системе, который отвечает за создание, запуск и уничтожение Docker контейнеров. Демон — это процесс, который запущен в операционной системе, с которой взаимодействует клиент.
- *Docker Client* (Docker клиент) - Утилита командной строки, которая позволяет пользователю взаимодействовать с демоном. Существуют другие формы клиента, например, [Kitematic](https://kitematic.com/), с графическим интерфейсом.
- *Docker Hub* - [Реестр Docker образов](https://hub.docker.com/explore/). Грубо говоря, архив всех доступных образов. Если нужно, то можно содержать собственный реестр и использовать его для получения образов.


<a href="#table-of-contents" class="Top">К оглавлению</a>
<a id="webapps"></a>

## 2 Веб-приложения в Docker

Супер! Теперь мы научились работать с `docker run`, поиграли с несколькими контейнерами и разобрались в терминологии. Вооруженные этими знаниями, мы готовы переходить к реальным задачам: разворачиванию веб-приложений с Docker!

<a id="static-site"></a>

### 2.1 Статичные сайты

Давайте начнем с малого. Вначале рассмотрим самый простой статический веб-сайт. Скачаем образ из [Docker Hub](https://hub.docker.com/), запустим контейнер и посмотрим, насколько легко будет запустить веб-сервер.

Поехали. Для одностраничного сайта нам понадобится образ, заранее созданный для этого пособия и размещённый в [реестре](https://hub.docker.com/r/prakhar1989/static-site/) - prakhar1989/static-site. Можно запустить образ напрямую командой `docker run`.

```
$ docker run prakhar1989/static-site
```
Так как образа не существует локально, клиент сначала скачает образ из реестра, а потом запустит его. Если всё пройдёт без проблем, то вы увидите в терминале сообщение `Nginx is running...`. Теперь сервер запущен. Как увидеть сайт в действии? На каком порту работает сервер? И, что самое важное, как напрямую достучаться до контейнера из хост системы?

В нашем случае клиент не открывает никакие порты, так что нужно будет перезапустить команду  `docker run` чтобы сделать порты публичными. Заодно давайте сделаем так, чтобы терминал не был прикреплен к запущенному контейнеру. В таком случае можно будет спокойно закрыть терминал, а контейнер продолжит работу. Этот режим называется **detached**.

```
$ docker run -d -P --name static-site prakhar1989/static-site
e61d12292d69556eabe2a44c16cbd54486b2527e2ce4f95438e504afb7b02810
```

Флаг `-d` открепит (detach) терминал, флаг `-P` сделает все открытые порты публичными и случайными, и, наконец, флаг `--name` это имя, которое мы хотим дать контейнеру. Теперь можно увидеть порты с помощью команды `docker port [CONTAINER]`.


```
$ docker port static-site
80/tcp -> 0.0.0.0:32769
443/tcp -> 0.0.0.0:32768
```

Вы можете открыть [http://localhost:32769](http://localhost:32769) в своём браузере. 

> Замечание. Если вы используете docker-toolbox, вам потребуется узнать ip адрес машины, например, с помощью команды `docker-machine ip default`. Если вы используете собственную виртуальную машину в ней вы можете выполнить команду `ip addr`. 

Вы также можете назначить свой порт, на который Docker клиент будет перенаправлять запросы на соединение к контейнеру.

```
$ docker run -p 8888:80 prakhar1989/static-site
Nginx is running...
```
Ключ `-p` устанавливает соответствие между портом хост операционной системы (8888) с портом контейнера (80).

<p align="center">
    <img src="https://raw.githubusercontent.com/protsenkovi/docker-curriculum/master/images/static.png" title="static">
    Страница статичного сайта
</p>

Чтобы остановить контейнер запустите `docker stop` и укажите идентификатор (ID) контейнера.

Согласитесь, все было очень просто. Чтобы развернуть это на реальный сервер, нужно просто установить Docker на него и запустить команду выше. Теперь, когда вы увидели, как запускать веб-сервер внутри образа, вам, наверное, интересно — а как создать свой Docker образ? Следующий раздел посвящён этой теме.

<a id="docker-images"></a>
### 2.2 Docker образы

Мы касались образов ранее, но в этом разделе мы заглянем глубже: что такое Docker образы и как создавать собственные образы. Наконец, мы используем собственный образ чтобы запустить приложение локально, а потом развернём его на [AWS](http://aws.amazon.com), чтобы показать друзьям. Круто? Круто! Давайте начнем.

Образы это основы для контейнеров. В прошлом примере мы скачали (**pull**) образ под названием Busybox из регистра, и попросили клиент Docker запустить контейнер, **основанный** на этом образе. Чтобы увидеть список доступных локально образов, используйте команду `docker images`.

```
$ docker images
REPOSITORY                      TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
prakhar1989/catnip              latest              c7ffb5626a50        2 hours ago         697.9 MB
prakhar1989/static-site         latest              b270625a1631        21 hours ago        133.9 MB
python                          3-onbuild           cf4002b2c383        5 days ago          688.8 MB
martin/docker-cleanup-volumes   latest              b42990daaca2        7 weeks ago         22.14 MB
ubuntu                          latest              e9ae3c220b23        7 weeks ago         187.9 MB
busybox                         latest              c51f86c28340        9 weeks ago         1.109 MB
hello-world                     latest              0a6ba66e537a        11 weeks ago        960 B
```

Это список образов, скачанных из реестра, а также тех, что сделаны самостоятельно (скоро увидим, как это делать). `TAG` — это конкретный снимок (snapshot) образа, а `IMAGE ID` — это соответствующий уникальный идентификатор образа.

Для простоты, можно относиться к образу как к git-репозиторию. Образы можно [коммитить](https://docs.docker.com/engine/reference/commandline/commit/) с изменениями, и можно иметь несколько версий. Если не указывать конкретную версию, то клиент по умолчанию использует `latest`. Например, можно скачать определенную версию образа `ubuntu`:
```
$ docker pull ubuntu:12.04
```
Чтобы получить новый Docker образ, можно скачать его из реестра (такого, как Docker Hub) или создать собственный. На Docker Hub есть десятки тысяч образов. Поиск среди них доступен как на сайте, так и из командной строки с помощью `docker search`.

Важно понимать разницу между базовыми и дочерними образами:

- **Base image** (базовый образ) — это образ, который не имеет родительского образа. Обычно это образы с операционной системой, такие как ubuntu, busybox или debian.
- **Child image** (дочерний образ) — это образ, построенный на базовых образах и обладающий дополнительной функциональностью.

Существуют официальные и пользовательские образы, и любые из них могут быть базовыми и дочерними.

- **Официальные образы** — это образы, которые официально поддерживаются командой Docker. Обычно в их названии одно слово. В списке выше python, ubuntu, busybox и hello-world — базовые образы.
- **Пользовательские образы** — образы, созданные простыми пользователями вроде нас. Они построены на базовых образах. Обычно, они называются по формату user/image-name.

<a id="our-image"></a>
### 2.3 Наш первый образ

Теперь, когда мы лучше понимаем, что такое образы и какие они бывают, самое время создать собственный образ. Цель этого раздела — создать образ с простым приложением на [Flask](http://flask.pocoo.org). Для этого пособия подготовлено [маленькое приложение](https://github.com/prakhar1989/docker-curriculum/tree/master/flask-app), которое выводит случайную картинку с кошкой. Склонируйте этот репозиторий к себе на локальную машину `git clone <адрес-репозитория>`.

Следующим шагом является создание образа с данным веб-приложением. Как говорилось выше, все пользовательские образы базируются на базовых образах. Так как приложение написано на Python, базовый образ следует выбрать с предустановленным [Python 3](https://hub.docker.com/_/python/). Точнее мы собираемся использовать `python:3-onbuild` версию python образа.

Что ещё за [`onbuild`](https://docs.docker.com/engine/reference/builder/#onbuild) версия вы можете спросить?

> Данные образы включают множество onbuild триггеров, которых должно хватить для запуска большинства приложений. При построении скопируется `requirements.txt` файл, запустится `pip install` на основе этого файла и затем скопируется текущая директория в `/usr/src/app`.

Другими словами `onbuild` версия образа содержит скрипты-помощники для автоматизации рутинных задач необходимых для запуска приложения. Вместо выполнения этих задач вручную (или написания для этого скриптов), эти образы делают эту работу за вас. Теперь у нас есть все ингредиенты для создания собственных образов - работающее веб-приложение и базовый образ. Как мы будем подходить к этой задаче? Ответ - **Dockerfile**.

<a id="dockerfiles"></a>
### 2.4 Dockerfile

[Dockerfile](https://docs.docker.com/engine/reference/builder/) — это простой текстовый файл, в котором содержится список команд Docker клиента. Это простой способ автоматизировать процесс создания образа. Самое классное, что [команды](https://docs.docker.com/engine/reference/builder/#from) в Dockerfile почти идентичны своим аналогам в Linux. Это значит, что в принципе не нужно изучать новый синтаксис, чтобы начать работать с докер-файлами.

В директории с приложением есть `Dockerfile`, но так как мы делаем все впервые, нам нужно создать его с нуля. Создайте новый пустой файл в любимом текстовом редакторе, и сохраните его в **той же** директории, где находится flask-приложение. Назовите файл `Dockerfile`.

Для начала укажем базовый образ. Для этого нужно использовать ключевое слово `FROM`.
```
FROM python:3-onbuild
```
Следующим шагом обычно указывают команды для копирования файлов и установки зависимостей. Но к счастью, `onbuild`-версия базового образа берет эти задачи на себя. Дальше нам нужно указать порт, который следует открыть. Наше приложение работает на порту `5000`, поэтому укажем его:
```
EXPOSE 5000
```
Последний шаг — указать команду для запуска приложения. Это просто `python ./app.py`. Для этого используем команду [CMD](https://docs.docker.com/engine/reference/builder/#cmd):
```
CMD ["python", "./app.py"]
```

Главное предназначение `CMD` — это сообщить контейнеру какие команды нужно выполнить при старте. Теперь наш `Dockerfile` готов. Вот как он выглядит:
```
# our base image
FROM python:3-onbuild

# specify the port number the container should expose
EXPOSE 5000

# run the application
CMD ["python", "./app.py"]
```

Теперь можно создать образ. Команда `docker build` занимается сложной задачей создания образа на основе `Dockerfile`.

Листинг ниже демонстрирует процесс. Перед тем, как запустите команду сами (не забудьте точку в конце), проверьте, чтобы там был ваш username. Username должен соответствовать тому, что использовался при регистрации на [Docker hub](https://hub.docker.com). Если вы еще не регистрировались, то сделайте это до выполнения команды. Команда `docker build` довольно проста: она принимает опциональный тег с флагом `-t имя_пользователя/имя_образа` и путь до директории, в которой лежит `Dockerfile`.
```
$ docker build -t имя_пользователя/имя_образа .
Sending build context to Docker daemon 8.704 kB
Step 1 : FROM python:3-onbuild
# Executing 3 build triggers...
Step 1 : COPY requirements.txt /usr/src/app/
 ---> Using cache
Step 1 : RUN pip install --no-cache-dir -r requirements.txt
 ---> Using cache
Step 1 : COPY . /usr/src/app
 ---> 1d61f639ef9e
Removing intermediate container 4de6ddf5528c
Step 2 : EXPOSE 5000
 ---> Running in 12cfcf6d67ee
 ---> f423c2f179d1
Removing intermediate container 12cfcf6d67ee
Step 3 : CMD python ./app.py
 ---> Running in f01401a5ace9
 ---> 13e87ed1fbc2
Removing intermediate container f01401a5ace9
Successfully built 13e87ed1fbc2
```

Если у вас нет образа `python:3-onbuild`, то клиент сначала скачает его, а потом возьмётся за создание вашего образа. Так что, вывод на экран может отличаться от приведённого выше. Посмотрите внимательно, и найдете триггеры onbuild. Если все прошло хорошо, то образ готов! Запустите `docker images` и увидите свой образ в списке.

Последний шаг — запустить образ и проверить его работоспособность (замените username на свой):
```
$ docker run -p 8888:5000 имя_пользователя/имя_образа
 * Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)
 ```

Зайдите на указанный URL и увидите приложение в работе.

<p align="center">
    <img src="https://raw.githubusercontent.com/prakhar1989/docker-curriculum/master/images/catgif.png" title="static">
    Python веб-приложение
</p>

Поздравляю! Вы успешно создали свой первый Docker образ!

<a id="docker-aws"></a>
### 2.5 Docker on AWS

Что хорошего в приложении, которое нельзя показать друзьям, правда? Так что в этом разделе мы научимся разворачивать наше приложение в облако. Будем использовать AWS [Elastic Beanstalk](https://aws.amazon.com/elasticbeanstalk/), чтобы решить эту задачу за пару кликов. Мы увидим, как с помощью Beanstalk легко управлять нашим приложением.


##### Docker push

Первое, что нужно сделать перед развёртыванием на AWS это опубликовать наш образ в реестре, для того, чтобы можно было скачивать его из AWS. Есть несколько [Docker реестров](https://aws.amazon.com/ecr/) (или можно создать собственный). Для начала, давайте используем [Docker Hub](https://hub.docker.com). Для публикации образа просто выполните:

```
$ docker push имя_пользователя/имя_образа
```
Если это ваша первая публикация, то клиент попросит вас залогиниться. Введите те же данные, что используете для входа в [Docker Hub](https://hub.docker.com).

```
$ docker login
Username: имя_пользователя
WARNING: login credentials saved in /Users/prakhar/.docker/config.json
Login Succeeded
```
Не забудьте заменить название образа на своё. Очень важно сохранить формат `имя_пользователя/имя_образа`, чтобы клиент понимал, куда публиковать образ.

После этого можете посмотреть на свой образ на Docker Hub. Например, вот [страница](https://hub.docker.com/r/prakhar1989/catnip/) уже выложенного образа.

> Замечание. Один важный момент, который стоит прояснить перед тем, как продолжить — **не обязательно** хранить образ в публичном реестре (или в любом другом реестре вообще), чтобы разворачивать на AWS. Если вы пишете код для следующего многомиллионного стартапа-единорога, то можно пропустить этот шаг. Мы публикуем свой образ, чтобы упростить развёртывание, опустив несколько конфигурационных шагов.

Теперь наш образ выложен онлайн, и любой докер-клиент может поиграться с ним с помощью простой команды:

```
$ docker run -p 8888:5000 имя_пользователя/имя_образа
```

Если в прошлом вы мучались с установкой локального рабочего окружения и попытками поделиться своей конфигурацией с коллегами, то понимаете, как круто это звучит. Вот почему Docker — это сила!


##### Beanstalk

AWS Elastic Beanstalk (EB) это PaaS (Platform as a Service — платформа как сервис) от Amazon Web Services. Если вы использовали Heroku, Google App Engine и т.д., то все будет привычно. Как разработчик, вы сообщаете EB как запускать ваше приложение, а EB занимается всем остальным, в том числе масштабированием, мониторингом и даже обновлениями. В апреле 2014 в EB добавили возможность запускать Docker контейнеры, и мы будем использовать именно эту возможность для развёртывания. У EB очень понятный [интерфейс командной строки](http://docs.aws.amazon.com/elasticbeanstalk/latest/dg/eb-cli3.html), но он требует небольшой конфигурации, поэтому для простоты давайте используем веб-интерфейс для запуска нашего приложения.

Чтобы продолжать, вам потребуется работающий аккаунт на [AWS](http://aws.amazon.com). Если у вас его нет, то создайте его. Для этого потребуется ввести данные кредитной карты. Но не волнуйтесь, эта услуга бесплатна, и все, что будет происходить в рамках этого пособия тоже бесплатно.

Давайте начнём:

- Войдите в свою [консоль](http://console.aws.amazon.com) AWS.
- Нажмите на Elastic Beanstalk. Ссылка находится в секции compute, в левом верхнем углу. Или просто перейдите [сюда](https://console.aws.amazon.com/elasticbeanstalk).

<img src="https://raw.githubusercontent.com/protsenkovi/docker-curriculum/master/images/eb-start.png" title="static">

- Нажмите на "Create New Application" в верхнем правом углу.
- Дайте своему приложению запоминающееся (но уникальное) имя и, если хотите, добавьте описание.
На экране появившемся экране создайте новое окружение **Environment**. 
- Во всплывшем окне **Choose an environment tier** выберите **Web Server Environment**.
- Следующий экран показан ниже. Указав платформу **Docker**, нажмите на **Create environment**.

<img src="https://raw.githubusercontent.com/protsenkovi/docker-curriculum/master/images/eb-newenv.png" title="static">

- На последнем экране будет несколько крутящихся индикаторов прогресса. Это поднимается и настраивается ваше окружение. Обычно, нужно около пяти минут для первой настройки.

Пока мы ждём, давайте быстренько взглянем на файл `Dockerrun.aws.json`. Это файл для AWS, в котором находится информация о приложении конфигурации Докера. EB получает информацию из этого файла.

```
{
  "AWSEBDockerrunVersion": "1",
  "Image": {
    "Name": "prakhar1989/catnip",
    "Update": "true"
  },
  "Ports": [
    {
      "ContainerPort": "5000"
    }
  ],
  "Logging": "/var/log/nginx"
}
```

Файл довольно понятный, но всегда можно обратиться к [официальной документации](http://docs.aws.amazon.com/elasticbeanstalk/latest/dg/create_deploy_docker_image.html). Мы указываем название образа, и EB будет использовать его заодно с портом.

К этому моменту окружение уже должно быть готово. Зайдите на страницу EB и увидите зелёный индикатор успешного запуска.

<img src="https://raw.githubusercontent.com/protsenkovi/docker-curriculum/master/images/eb-started.png" title="static">

- Тут мы будем сообщать системе EB о нашем образе. Откройте файл `Dockerrun.aws.json` в директории `flask-app` и измените Name образа, чтобы оно соответствовало названию вашего образа. Не волнуйтесь, я опишу содержание файла попозже. Потом выберите вариант "upload and deploy" и выберите файл.

<img src="https://raw.githubusercontent.com/protsenkovi/docker-curriculum/master/images/eb-deploying.png" title="static">

<img src="https://raw.githubusercontent.com/protsenkovi/docker-curriculum/master/images/eb-deploy.png" title="static">

Зайдите на указанный URL в браузере и увидите приложение во всей красе. Пошлите адрес своим друзьям, чтобы все могли насладиться гифками с кошками.

Поздравляю! Вы развернули свое первое Docker приложение! Может показаться, что было очень много шагов, но с командной утилитой EB можно имитировать функциональность Heroku несколькими нажатиями клавиш. Надеюсь, вы согласитесь, что Docker сильно упрощает процесс и минимизирует болезненные моменты развёртывания в облако. 

> Совет. Прочитайте [документацию](http://docs.aws.amazon.com/elasticbeanstalk/latest/dg/docker-singlecontainer-deploy.html) AWS про single-container Docker environment, чтобы понимать, какие существуют возможности в EB.

<a href="#table-of-contents" class="Top">К оглавлению</a>
